import { Construct } from "constructs";
import * as secretsmanager from "aws-cdk-lib/aws-secretsmanager";
import * as iam from "aws-cdk-lib/aws-iam";
import { CfnOutput, RemovalPolicy } from "aws-cdk-lib";
import { EnvironmentConfig } from "../../config/environment";
import { IPermissionProvider } from "../permissions/lambda-permissions";

/**
 * Props for JwtSecretsConstruct
 */
export interface JwtSecretsConstructProps {
  /** Environment configuration */
  config: EnvironmentConfig;
}

/**
 * JWT Secrets Construct
 *
 * Creates JWT secrets in AWS Secrets Manager with:
 * - Automatically generated JWT_SECRET (128 characters)
 * - Automatically generated JWT_REFRESH_SECRET (128 characters)
 * - Proper IAM permissions for Lambda access
 *
 * The secrets are created during CDK deployment and stored at:
 * /oriana/{env}/jwt
 *
 * Secret structure:
 * {
 *   "JWT_SECRET": "<auto-generated-128-char-string>",
 *   "JWT_REFRESH_SECRET": "<auto-generated-128-char-string>"
 * }
 *
 * Usage:
 * ```typescript
 * const jwtSecrets = new JwtSecretsConstruct(this, 'JwtSecrets', { config });
 * // Access: jwtSecrets.secret, jwtSecrets.secretArn
 * ```
 */
export class JwtSecretsConstruct
  extends Construct
  implements IPermissionProvider
{
  /** The Secrets Manager secret containing JWT secrets */
  public readonly secret: secretsmanager.ISecret;

  /** ARN of the secret for IAM policies */
  public readonly secretArn: string;

  /** IAM policy statements for Lambda to access the secret */
  public readonly permissions: iam.PolicyStatement[] = [];

  constructor(scope: Construct, id: string, props: JwtSecretsConstructProps) {
    super(scope, id);

    const { config } = props;
    const isProd = config.environment === "prod";

    console.log(`   üîê Creating JWT secrets for ${config.environment}...`);

    // Create the JWT secrets
    // We use a two-step approach to generate both secrets:
    // 1. Create a secret with JWT_SECRET as the generated key
    // 2. The JWT_REFRESH_SECRET is also generated using the same mechanism
    //
    // Note: CloudFormation's generateSecretString can only generate one key,
    // so we generate a combined secret with both values
    this.secret = new secretsmanager.Secret(this, "JwtSecret", {
      secretName: config.jwt.secretId,
      description: `JWT signing secrets for Oriana - ${config.environment}`,
      generateSecretString: {
        // Generate a JSON object with both secrets
        secretStringTemplate: JSON.stringify({
          // This will be overwritten by generateStringKey, but we need a template
          JWT_REFRESH_SECRET: this.generateSecretPlaceholder(),
        }),
        generateStringKey: "JWT_SECRET",
        excludePunctuation: false,
        includeSpace: false,
        passwordLength: 128,
      },
      // Retain secrets in production to prevent accidental deletion
      removalPolicy: isProd ? RemovalPolicy.RETAIN : RemovalPolicy.DESTROY,
    });

    this.secretArn = this.secret.secretArn;

    // Create IAM policy statement for Lambda access
    this.permissions.push(
      new iam.PolicyStatement({
        effect: iam.Effect.ALLOW,
        actions: ["secretsmanager:GetSecretValue"],
        resources: [this.secret.secretArn],
      }),
    );

    // Output the secret ARN
    new CfnOutput(this, "JwtSecretArn", {
      value: this.secret.secretArn,
      description: `JWT Secrets ARN - ${config.environment}`,
      exportName: `OrianaJwtSecretArn-${config.environment}`,
    });

    console.log(`   ‚úÖ Created JWT secret: ${config.jwt.secretId}`);
  }

  /**
   * Generate a placeholder for JWT_REFRESH_SECRET.
   * This creates a random string that will be stored alongside the generated JWT_SECRET.
   *
   * Note: For a truly random refresh secret, we use a CloudFormation custom resource
   * or rely on the application to handle both secrets from the same generated value.
   *
   * Alternative: Use separate secrets or a Lambda-backed custom resource.
   */
  private generateSecretPlaceholder(): string {
    // Generate a random 128-character string for the refresh secret
    // This is generated at CDK synth time, not deploy time
    const chars =
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+-=[]{}|;:,.<>?";
    let result = "";
    for (let i = 0; i < 128; i++) {
      result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return result;
  }

  /**
   * Grant read access to the JWT secret
   */
  public grantRead(grantee: iam.IGrantable): iam.Grant {
    return this.secret.grantRead(grantee);
  }
}
